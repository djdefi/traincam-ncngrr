<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TrainCam WebRTC Viewer</title>
<style>
 body { margin:0; background:#111; color:#eee; font:14px system-ui, sans-serif; display:flex; flex-direction:column; align-items:center; }
 header { padding:0.75rem 1rem; width:100%; box-sizing:border-box; background:#222; }
 h1 { margin:0; font-size:1.1rem; }
 #status { font-size:0.8rem; opacity:0.8; }
 video { width: min(100vw, 70vh * 1280/720); max-width:1280px; background:#000; margin-top:0.5rem; }
 button { background:#333; color:#eee; border:1px solid #555; padding:0.4rem 0.8rem; cursor:pointer; margin-right:0.4rem; }
 button:hover { background:#444; }
 footer { margin:1rem 0 2rem; font-size:0.7rem; opacity:0.6; }
 .row { margin-top:0.5rem; }
</style>
</head>
<body>
  <header>
    <h1>TrainCam WebRTC Viewer</h1>
    <div id="status">Idle</div>
  </header>
  <div class="row">
    <button id="connectBtn">Connect</button>
    <button id="disconnectBtn" disabled>Disconnect</button>
    <label style="font-size:0.8rem;">Auto-reconnect <input type="checkbox" id="autorec" checked></label>
  </div>
  <video id="video" autoplay playsinline muted></video>
  <footer>WebRTC playback via MediaMTX. Latency target &lt; 500ms on LAN.</footer>
<script>
// Basic WHEP (WebRTC HTTP Egress Protocol) style playback for MediaMTX
// Assumes MediaMTX is serving HTTP(S) on same host/port as this file is opened from.

const PATH = 'traincam';
const AUTOREC_DELAY_MS = 1500;
let pc; let abortController; let reconnectTimer;
const statusEl = document.getElementById('status');
const videoEl = document.getElementById('video');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const autorec = document.getElementById('autorec');

function log(msg){ console.log(msg); statusEl.textContent = msg; }

async function connect() {
  if (pc) { log('Already connected'); return; }
  abortController = new AbortController();
  log('Creating PeerConnection...');
  pc = new RTCPeerConnection({
    iceServers: [] // LAN usage; add STUN/TURN if crossing NATs
  });
  pc.addEventListener('track', ev => {
    if (ev.track.kind === 'video') {
      videoEl.srcObject = ev.streams[0];
    }
  });
  pc.addEventListener('connectionstatechange', () => {
    log('State: ' + pc.connectionState);
    if (['disconnected','failed','closed'].includes(pc.connectionState)) {
      cleanup();
      if (autorec.checked) scheduleReconnect();
    }
  });

  // Create a recvonly transceiver for video.
  pc.addTransceiver('video', { direction: 'recvonly' });

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  log('Preparing WHEP offer...');
  // Determine WHEP base: force MediaMTX port 8889 by default (python server is 8080)
  // Allow override via ?whepPort=PORT or full ?whepBase=http://host:port
  const qs = new URLSearchParams(window.location.search);
  const explicitBase = qs.get('whepBase');
  const whepPort = qs.get('whepPort') || '8889';
  let base;
  if (explicitBase) {
    try { base = new URL(explicitBase).origin; } catch(_) { base = null; }
  }
  if (!base) {
    base = `${window.location.protocol}//${window.location.hostname}:${whepPort}`;
  }
  const endpoint = `${base.replace(/\/$/, '')}/whep/${PATH}`;
  log('POST offer to ' + endpoint + ' ...');
  let resp;
  try {
    resp = await fetch(endpoint, {
      method: 'POST',
      body: offer.sdp,
      headers: { 'Content-Type': 'application/sdp' },
      signal: abortController.signal
    });
  } catch (e) {
    log('Fetch error: ' + e);
    cleanup();
    if (autorec.checked) scheduleReconnect();
    return;
  }
  if (!resp.ok) {
    log('WHEP offer rejected: ' + resp.status);
    cleanup();
    if (autorec.checked) scheduleReconnect();
    return;
  }
  const answerSdp = await resp.text();
  await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });
  log('Connected');
  connectBtn.disabled = true; disconnectBtn.disabled = false;
}

function cleanup() {
  if (abortController) abortController.abort();
  if (pc) {
    pc.getSenders().forEach(s => { try { s.track && s.track.stop(); } catch(_){} });
    pc.close();
  }
  pc = null;
  connectBtn.disabled = false; disconnectBtn.disabled = true;
}

function scheduleReconnect() {
  if (reconnectTimer) return;
  reconnectTimer = setTimeout(() => { reconnectTimer = null; connect(); }, AUTOREC_DELAY_MS);
  log('Reconnecting in ' + AUTOREC_DELAY_MS + 'ms...');
}

connectBtn.onclick = () => { if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer=null; } connect(); };
DisconnectBtn = disconnectBtn; // alias for case-insensitive
DisconnectBtn.onclick = () => { if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer=null; } autorec.checked=false; cleanup(); log('Disconnected'); };

// Auto connect on load
window.addEventListener('load', () => { connect(); });
</script>
</body>
</html>
